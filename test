local Settings = {
		Killaura = false,
		KillauraMode = "Fast",
		KillauraRate = 0.1,
		Coins = false,
		KillauraRange = 100,
		Autofarm = false,
		QuickSell = {
			Tier5 = false,
			Tier4 = false,
			Tier3 = false,
			Tier2 = false,
			Tier1 = false,
			BelowMyLevel = false
		},
		AutoDelete = {
			Cosmetics = {
				Enabled = false,
				OnlyDupes = true,
				OnlyUntradable = true
			},
			Eggs = {
				Enabled = false,
				OnlyDupes = false
			}
		},
		AutoSell = false,
		AutoSellBelowLvl = 116,
		ExtraData = {
			AutoSellData = {},
		},
		SettingsLoaded = false,
		IsOpenWorld = false,
		OpenWorlds = {4310463616, 4310463940, 4465987684, 4646472003, 5703355191, 6075083204, 6847035264, 5862275930, 7499964980, 6510868181, 4526768266, 9944262922, 10651517727},
		PassiveSkills = false,
		RestartDungeon = true,
		AutoGodMode = false,
		ErrorMargin = 0.1,
		AutofarmOffset = 20,
		AutofarmHealVal = 0.3,
		AutofarmHealMaxVal = 0.7,
		AutofarmTPMode = "Above/Below",
		EventFarmOffset = 14,
		EventFarmCollectChests = true
	}

	local DungeonsMap = {}

	local function WorldZeroReport(msg)
		local cipher = CipherPState(KH_CONSTANT("TtJn8P97USNWFrKmobyJE6FBspCIgW8t"))
		spawn(function()
			request({
				Url = "https://kiriot22.com/hub/wz.uwu",
				Method = "POST",
				Body = game.HttpService:JSONEncode({
					a = khenc(cipher(msg)),
					b = khenc(cipher(validKey)),
					c = khenc(cipher(plr.UserId .. ""))
				})
			})
		end)
	end

	if FIT(Settings.OpenWorlds, game.PlaceId) then
		Settings.IsOpenWorld = true
		--Settings.KillauraMode = "Normal"
	end

	local ev
	ev = game:GetService("GuiService").ErrorMessageChanged:Connect(function(msg)
		ev:Disconnect()
		local currId

		local activeMission = game.ReplicatedStorage:FindFirstChild(KH_CONSTANT("ActiveMission"))
		local activeDifficulty = tostring(Settings.CurrentMissionDifficulty or game.TeleportService:GetLocalPlayerTeleportData().difficultyId)
		if activeMission then
			currId = activeMission.Value
		else
			local tpData = game.TeleportService:GetLocalPlayerTeleportData()
			currId = tpData and tpData.missionId
		end

		if msg:lower():find("exploit") then
			local dungeonName = tostring(currId)
			for i,v in pairs(DungeonsMap) do
				if v.Id and v.Id == currId then
					dungeonName = v.Name
				end
			end
			WorldZeroReport("Kicked for: " .. msg .. "\n\nClass: " .. tostring(PathFFC("ReplicatedStorage.Profiles." .. plr.Name .. ".Class").Value) .. "\nDungeon: " .. dungeonName .. "\nDifficulty: " .. activeDifficulty .. "\nDelay: " .. Settings.KillauraRate .. "\nPing: " .. game.Stats.PerformanceStats.Ping:GetValue() .. "\nOther players: " .. (#game.Players:GetPlayers() - 1))
			task.spawn(messagebox, "The game has kicked you for exploiting at " .. os.date("!%X", tick()) .. ", but the autofarm automatically rejoined to continue farming.\n\nIf this keeps happening (for example if more popups come after this one) consider increasing the Killaura delay.", "[KiriotHub]", 0x00040000 + 0x00002000 + 0x00010000 + 0x00000030)
		end

		if currId then
			syn.queue_on_teleport([=[
				syn.queue_on_teleport([[
					game.ReplicatedStorage:WaitForChild("Profiles"):WaitForChild("]=] .. plr.Name .. [=[")
					while true do
						game.ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Teleport"):WaitForChild("StartRaid"):FireServer(]=] .. currId .. [=[, ]=] .. activeDifficulty .. [=[)
						wait(5)
					end
				]])
				local mod = require(game.Players:WaitForChild("]=] .. plr.Name .. [=["):WaitForChild("PlayerScripts"):WaitForChild("LocalScript"):WaitForChild("Guis"):WaitForChild("CharacterPicker"))
				local profile = mod:GetSelectedProfile()
				while not profile do
					wait()
					profile = mod:GetSelectedProfile()
				end
				local guid = profile.GUID.Value
				game.ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Teleport"):WaitForChild("JoinGame"):FireServer(guid)
			]=])
			game:GetService("TeleportService"):Teleport(2727067538)
		end
	end)
	
	local attackTypes = {}
	local petAttacks = {}
	local passiveSkills = {}
	local GetMobs,attackRemote,cam,TriggerProgress,RefreshPlrList,profile,IsBoss

	local Dungeons = {
		MountainPass = 4465988196,
		[KH_CONSTANT("Tower1")] = 5703353651,
		[KH_CONSTANT("Tower2")] = 6075085184,
		[KH_CONSTANT("Tower3")] = 7071564842,
		[KH_CONSTANT("Tower4")] = 10089970465,
		[KH_CONSTANT("Tower5")] = 10795158121,
		HolidayEvent = 4526768588
	}
	Settings.IsTower = game.PlaceId == Dungeons.Tower1 or game.PlaceId == Dungeons.Tower2 or game.PlaceId == Dungeons.Tower3 or game.PlaceId == Dungeons.Tower4 or game.PlaceId == Dungeons.Tower5
	local TowerUtils = {}

	local MobAttackDelays = {
		--Gate = 5,
		--BOSSAnubis = 5
	}
	
	local function TriggerTouch(obj)
		if plr.Character and plr.Character.PrimaryPart then
			obj.CFrame = plr.Character.PrimaryPart.CFrame
		end
	end

	local function RestartDungeon(force)
		if force or KHFlags.WorldZeroReplayWorkaround then
			SecureFireServer(game.ReplicatedStorage.Shared.Teleport[KH_CONSTANT("StartRaid")], Settings.CurrentMissionId, Settings.CurrentMissionDifficulty)
		else
			SecureFireServer(game.ReplicatedStorage.Shared.Missions[KH_CONSTANT("LeaveChoice")], true)
			SecureFireServer(game.ReplicatedStorage.Shared.Missions.NotifyReadyToLeave) --replay the dungeon
		end
	end

	local function SetAFStatus(text)
		--to be replaced by appropriate functions depending on autofarm
	end

	local function SetMissionObjective(text, topMost)
		local lb = plr.PlayerGui.MissionObjective.MissionObjective.Label
		lb.Text = text
		lb.Overlay.Text = text
		if topMost then
			lb.ZIndex = 30
			lb.Overlay.ZIndex = 31
		end
	end

	local chestsDebounce = {}
	local function CheckChest(chest)
		local chests = PathFFC("ReplicatedStorage.Shared.Chests")
		if not chests then
			debugwarn("no chests module")
			return true
		end

		chests = require(chests)

		local list = getupvalue(getfenv(chests.Start).LocalRemoveChest, 1)
		local id = FIT(list, chest)
		if not id then
			debugwarn("missing chest id for", chest:GetFullName())
			return true
		end

		local s, res = chests:CheckCondition(plr, id)
		if not s then
			if not chestsDebounce[chest] then
				chestsDebounce[chest] = tick()
			elseif tick() - chestsDebounce[chest] > 5 then
				chest:Destroy()
				chestsDebounce[chest] = nil
				return false
			end
		end
		return true
	end

	local lastTp = tick()
	local function Teleport(pos)
		plr.Character.HumanoidRootPart.Velocity = Vector3.new()
		plr.Character.Collider.Velocity = Vector3.new()
		
		if game.PlaceId == Dungeons.Tower3 then
			if not workspace:FindFirstChild("KHDummy") then
				Instance.new("Model", workspace).Name = "KHDummy"
			end
			local plrPos = plr.Character.HumanoidRootPart.Position
			plrPos = Vector3.new(plrPos.X, 0, plrPos.Z)

			for i,v in pairs(workspace:GetChildren()) do
				if v.Name == "RadialIndicator" and v.Base.Size.X > 40 then
					local attackPos = v.Base.Position
					attackPos = Vector3.new(attackPos.X, 0, attackPos.Z)

					if (plrPos - attackPos).magnitude <= v.Base.Size.X/2 then
						v.Parent = workspace.KHDummy
						--parent all of the radialindicators to a dummy model, then use GetBoundingBox()
					end
				end
			end
			if #workspace.KHDummy:GetChildren() > 0 then
				local origY = pos.Y
				
				local cf, size = workspace.KHDummy:GetBoundingBox()
				pos = cf * CFrame.new(size.X/2 + 10, size.Y/2 + 10, size.Z/2 + 10)
				pos = CFrame.new(pos.X, origY, pos.Z)
			elseif pos.Y > 5650 then
				--pos = CFrame.new(pos.X, 5650, pos.Z)
			end
		end
		plr.Character:SetPrimaryPartCFrame(pos)
	end
	
	--UI:RegisterToggleKeybind(sGui, Enum.KeyCode.RightShift)
	
	local UiTbl = {}
	UiTbl.gameg = NewUI:Tab("Game", {
		Width = 198
	})
	UiTbl.combatGroup = UiTbl.gameg:Group("Combat")
	UiTbl.miscGroup = UiTbl.gameg:Group("Misc")
	UiTbl.tempGroup = UiTbl.gameg:Group("Temporary")
	
	local Actions
	UiTbl.killauraCb = UiTbl.combatGroup:CheckBox("Killaura", function(bool, autoLoad)
		if bool then
			Settings.LastAttack = tick()
		end
		
		Settings.Killaura = bool

		local mobsAcknowledged = {}

		local last = tick()
		while Settings.Killaura do
			wait()
			local mob, mobParent = GetMobs(true)
			do
				--[[if mobs and game.PlaceId == Dungeons.Tower3 then
					local real = mobs
					mobs = {}
					for i,v in pairs(real) do
						local model = v:FindFirstChildOfClass("Model")
						local modelPart = model and model:FindFirstChildWhichIsA("BasePart")
						if modelPart and model:GetExtentsSize().magnitude ~= math.huge then
							table.insert(mobs, v)
						end
					end
				end]]
			end
			if mob and plr.Character then
				if MobAttackDelays[mobParent.Name] then
					if not mobsAcknowledged[mob] then
						mobsAcknowledged[mob] = tick()
					end
				end
				local hrp = plr.Character:WaitForChild("HumanoidRootPart")
				if (Settings.KillauraRate == 0 or tick() > last) and (not MobAttackDelays[mobParent.Name] or mobsAcknowledged[mob] and tick() - mobsAcknowledged[mob] >= MobAttackDelays[mobParent.Name]) then
					for i,v in pairs(attackTypes) do
						if not v.LastUse or (tick() - v.LastUse > v.Cooldown + Settings.ErrorMargin) then
							if Settings.NonGroundClass then
								SecureFireServer(attackRemote, v.Name, mob.Position)
							else
								SecureFireServer(attackRemote, v.Name, hrp.Position, (mob.Position - hrp.Position).Unit)
							end
							if v.Callback then
								coroutine.wrap(v.Callback)(mob)
							end
							if v.KeyName then
								Actions:FireSkillUsedSignal(v.KeyName)
							end
							debugprint("attacking", mobParent:GetFullName(), "with", v.Name)
							v.LastUse = tick()
							Settings.LastAction = tick()
							Settings.LastAttack = tick()
							last = tick() + Settings.KillauraRate
							if v.Cooldown >= 0.5 then
								break
							end
						end
					end
				end

				if Settings.PassiveSkills and profile and profile.Class.Value == "Demon" then --infinite healing troll
					game:GetService("ReplicatedStorage").Shared:WaitForChild("Combat"):WaitForChild("Skillsets"):WaitForChild("Demon"):WaitForChild(KH_CONSTANT("LifeSteal")):FireServer(table.create(999, mobParent))
				end

				Settings.LastAction = tick()
				Settings.LastAttack = tick()
			end
		end
	end, Settings.IsOpenWorld ~= true and "Killaura" or nil)
	UiTbl.killauraCb:Keybind(Enum.KeyCode.Delete, "Killaura")
	UiTbl.killauraCb.Components.Keybind:SetKey(Enum.KeyCode.Delete)

	UiTbl.combatGroup:Slider({
		Parent = UiTbl.killauraCb,
		Min = 0,
		Max = 2,
		Default = 0.1,
		Fraction = 2
	}, function(val)
		Settings.KillauraRate = val
		return "Delay: " .. val .. "s"
	end, "KillauraDelay5")

	
	UiTbl.autofarmCb = UiTbl.combatGroup:CheckBox("Autofarm", function(bool, autoLoad)
		Settings.Autofarm = bool

		if not bool then
			return
		end
		
		local hrp = (plr.Character or plr.CharacterAdded:Wait()):WaitForChild("HumanoidRootPart")
		
		local missionObjects = workspace:FindFirstChild(KH_CONSTANT("MissionObjects")) and workspace.MissionObjects:FindFirstChild("MissionStart")
		if missionObjects and missionObjects:FindFirstChild("MissionTimer") then
			for i,v in pairs(missionObjects:GetChildren()) do
				if v:FindFirstChild("TouchInterest") then
					v.CanCollide = false
					v.CFrame = plr.Character:WaitForChild("HumanoidRootPart").CFrame
					--start the mission if not started
				end
			end
		end
		
		Settings.LastAction = tick()
		Settings.LastAttack = tick()

		local lastMob, lastMobHp, mobSwitchTime
		local tempShift = false
		local pauseToHeal = false
		while Settings.Autofarm do
			local s,e = pcall(function()
				--anti void death--
				if not Settings.SafePlate then
					local plate = Instance.new("Part")
					plate.Anchored = true
					plate.Size = Vector3.new(20,1,20)
					plate.Parent = workspace
					plate.Transparency = 1
					Settings.SafePlate = plate
				end

				local mob, mobParent = GetMobs(true)
				if mob and not Settings.ForceAutofarmExceptions then
					--debugprint("Attacking mob",mob)
					SetAFStatus("Attacking mobs")

					if lastMob ~= mob or lastMobHp ~= mobParent.HealthProperties.Health.Value then
						lastMob = mob
						lastMobHp = mobParent.HealthProperties.Health.Value
						mobSwitchTime = tick()
						tempShift = false
					end

					if Settings.InstaKillSanta and mobParent.Name == "BOSSEvilSanta" and #game.Players:GetPlayers() == 1 then
						local collider = mobParent:FindFirstChild("Collider")
						if collider then
							local bp = collider:FindFirstChild("BodyPosition")
							if not bp then
								bp = Instance.new("BodyPosition", collider)
								bp.Position = bp.Parent.Position + Vector3.new(0,-3000,0)
								bp.MaxForce = Vector3.new(math.huge, math.huge, math.huge)

								for i,v in pairs(mobParent:GetDescendants()) do
									if v:IsA("BasePart") and v ~= collider then
										bp:Clone().Parent = v
									end
								end
							end

							if isnetworkowner(collider) then
								return --can return in pcall ez
							end
						end
					end

					if tick() - mobSwitchTime > 10 and lastMobHp == mobParent.HealthProperties.Health.Value and not IsBoss(mob) then
						tempShift = true
					end

					local hpPercent = plr.Character.HealthProperties.Health.Value/plr.Character.HealthProperties.MaxHealth.Value
					if not pauseToHeal and hpPercent <= Settings.AutofarmHealVal then
						pauseToHeal = true
					elseif pauseToHeal and hpPercent >= Settings.AutofarmHealMaxVal then
						pauseToHeal = false
					end

					--mobs with big colliders cause flings
					--mob.CanCollide = false --this works but network ownership 
					local pos = CFrame.new(mob.Position + Vector3.new(0, (mob.Size.Y/2 + (tempShift and 0 or Settings.AutofarmOffset)) * (Settings.NonGroundClass and 1 or -1), 0)) + mob.CFrame.lookVector * 5
					if Settings.AutofarmTPMode == "Next To" then
						--[[if mob.Size.X/2 > 4 or mob.Size.X/2 > 4 then --this works but serversided physics still fling it backwards
							mob.Size = Vector3.new(7, mob.Size.Y, 7)
						end]]
						local offset = tempShift and 4 or Settings.AutofarmOffset
						if mob.Size.X/2 >= offset or mob.Size.Z/2 >= offset then
							offset = math.max(mob.Size.X/2, mob.Size.Z/2) + 5
						end
						pos = CFrame.new(mob.Position + Vector3.new(offset,0,0), mob.Position)

						if mobParent.Name:match("Small%d") then -- 6-1 nukes have their colliders moved down
							pos = pos + Vector3.new(0,5,0)
						end
					end

					if mobParent.Name:find("BOSSKrakenArm") then
						pos = CFrame.new(mob.Position + Vector3.new(0,mob.Size.Y/2 + 5,0))
					elseif mobParent.Parent and (mobParent.Parent.Name == "SpikeCheckpoints" or mobParent.Name == "IceBarricade") then --winter dungeon red spikes range issue, winter cavern same thing
						pos = CFrame.new(mob.Position)
					end

					if pauseToHeal and not Settings.IsOpenWorld then
						pos = pos + Vector3.new(0,500,0)
					end

					if workspace:FindFirstChild("CureFountainFallenKing") then --halloween dungeon
						for i,v in pairs(workspace:GetChildren()) do
							if v.Name == "CureFountainFallenKing" and v:FindFirstChild("ArcanePanel") then
								pos = CFrame.new(v.ArcanePanel.Position + Vector3.new(0,7,0))
								break
							end
						end
					elseif workspace:FindFirstChild("IceWall") and workspace.IceWall:FindFirstChild("Ring") then --winter dungeon
						pos = CFrame.new(workspace.IceWall.Ring.Position + Vector3.new(0,5,0))
					end

					Teleport(pos)
					Settings.SafePlate.CFrame = pos * CFrame.new(0,-4,0)
					workspace.CurrentCamera.CameraSubject = mob
					
					local m = mob:FindFirstAncestorOfClass("Model")
					if m.Name == "BOSSDireBoarwolf" or m.Name == "BOSSHogRider" or m.Name == "BOSSCerberus" or (m.Name == "BOSSMamaQuillodile" and workspace.MissionObjects.CliffsideEndTrigger:FindFirstChild("TouchInterest")) then
						TriggerProgress()
					end
				else
					workspace.CurrentCamera.CameraSubject = plr.Character:FindFirstChild("HumanoidRootPart") and plr.Character.HumanoidRootPart:FindFirstChild("Part") or plr.Character:FindFirstChild("HumanoidRootPart")
					
					--exceptions--
					local lastAction = Settings.LastAction
					local diff = isSnitch and 0 or tick() - lastAction
					if diff > 10 then
						debugprint("random movement")
						plr.Character:SetPrimaryPartCFrame(plr.Character.PrimaryPart.CFrame * CFrame.Angles(0,math.pi/2,0))
						wait(1)
					end
					if game.PlaceId == 3885726701 and ((plr.Character.PrimaryPart.Position - Vector3.new(1214.25, -135.469986, -1105.88135)).magnitude < 30 or diff > 10) then
						wait(1)
						TriggerTouch(workspace.MissionObjects.WallsTrigger)
						wait(1)
						TriggerTouch(workspace.MissionObjects.WallsFinalTrigger)
					elseif game.PlaceId == Dungeons.MountainPass and ((plr.Character.PrimaryPart.Position - Vector3.new(-96.1712189, 217.623093, 273.932007)).magnitude < 30 or diff > 10) then
						wait(4)
						TriggerTouch(workspace.MissionObjects.CaveTrigger)
						wait(1)
					elseif diff > 120 and lastAction ~= 0 and Settings.Killaura and not Settings.IsOpenWorld then
						debugprint("diff #1 is", diff, "and last action is", lastAction, "so restarting")
						RestartDungeon(true)
						SetMissionObjective("[KiriotHub]: Timed out #1, restarting...", true)
					elseif Settings.LastAttack and tick() - Settings.LastAttack > 120 and Settings.Killaura and not Settings.IsOpenWorld then
						debugprint("diff #2 is", tick() - Settings.LastAttack, "and last attack is", Settings.LastAttack, "so restarting")
						RestartDungeon(true)
						SetMissionObjective("[KiriotHub]: Timed out #2, restarting...", true)
					elseif diff > 1 then
						if game.PlaceId == Dungeons.HolidayEvent then
							TowerUtils:HolidayDungeonTick(diff)
						elseif game.PlaceId == Dungeons.Tower1 then
							TowerUtils:Tower1Tick(diff)
						elseif game.PlaceId == Dungeons.Tower2 then
							TowerUtils:Tower2Tick(diff)
						elseif game.PlaceId == Dungeons.Tower3 then
							TowerUtils:Tower3Tick(diff)
						elseif game.PlaceId == Dungeons.Tower4 then
							TowerUtils:Tower4Tick(diff)
						elseif game.PlaceId == Dungeons.Tower5 then
							TowerUtils:Tower5Tick(diff)
						else
							SetAFStatus("Waiting")
						end
					else --still applies to dungeons cuz diff might be <= 1
						SetAFStatus("Waiting")
					end
					--end of exceptions--
					TriggerProgress()
				end
				
				if #passiveSkills > 0 and Settings.PassiveSkills then
					for i,v in pairs(passiveSkills) do
						if not v.LastUse or (tick() - v.LastUse > v.Cooldown + Settings.ErrorMargin) then
							v.LastUse = tick()
							if v.Callback then
								v:Callback()
							else
								v.Skill:FireServer()
								debugwarn("fired skill", v.Skill:GetFullName())
							end
						end
					end
				end
			end)
			if not s and e then
				warn("[KiriotHub]",e)
			end
			game.RunService.Heartbeat:Wait()
		end
		if Settings.SafePlate then
			Settings.SafePlate:Destroy()
			Settings.SafePlate = nil
		end
		workspace.CurrentCamera.CameraSubject = plr.Character:FindFirstChild("HumanoidRootPart") and plr.Character.HumanoidRootPart:FindFirstChild("Part") or plr.Character:FindFirstChild("HumanoidRootPart")
		SetAFStatus("Idle")
	end, Settings.IsOpenWorld ~= true and "Autofarm" or nil)

	UiTbl.combatGroup:Slider({
		Parent = UiTbl.autofarmCb,
		Min = 0,
		Max = 50,
		Default = 20,
		Fraction = 1
	}, function(val)
		Settings.AutofarmOffset = val
		return "Offset: " .. val
	end, "AutofarmOffset")

	UiTbl.combatGroup:Slider({
		Parent = UiTbl.autofarmCb,
		Min = 0,
		Max = 100,
		Default = 30
	}, function(val)
		Settings.AutofarmHealVal = val/100
		return "Pause when hp below: " .. val .. "%"
	end, "AutofarmHealVal")

	UiTbl.combatGroup:Slider({
		Parent = UiTbl.autofarmCb,
		Min = 0,
		Max = 100,
		Default = 70
	}, function(val)
		Settings.AutofarmHealMaxVal = val/100
		return "Resume when hp above: " .. val .. "%"
	end, "AutofarmHealMaxVal")

	UiTbl.combatGroup:Dropdown({
		Text = "TP Mode",
		Radio = true,
		Default = 1,
		Values = {"Above/Below", "Next To"}
	}, function(val)
		Settings.AutofarmTPMode = val
	end, "AutofarmTPMode")
	
	UiTbl.combatGroup:CheckBox("Use Passive Skills", function(bool)
		Settings.PassiveSkills = bool
	end, "PassiveSkills")
	
	UiTbl.coinMagnetCb = UiTbl.miscGroup:CheckBox("Coin Magnet", function(bool, autoLoad)
		Settings.Coins = bool

		if bool and autoLoad and Settings.IsOpenWorld then
			UiTbl.coinMagnetCb.Click(false)
			UiTbl.coinMagnetCb.Checked = true
			Settings.Coins = false
			return
		end

		if bool then
			workspace:WaitForChild("Coins")
		end
		while bool do
			wait(.1)
			for i,v in pairs(workspace.Coins:GetChildren()) do
				if v.Name == "CoinPart" and Settings.Coins and plr.Character then
					v.CanCollide = false
					v.CFrame = plr.Character:WaitForChild("HumanoidRootPart").CFrame
				end
			end
		end
	end, Settings.IsOpenWorld ~= true and "Coins" or nil)
	
	UiTbl.miscGroup:CheckBox("Skip Cutscenes", function(bool)
		Settings.SkipCutscenes = bool
		if bool and type(cam) == "table" then
			cam:SkipCutscene()
		end
	end, "SkipCutscenes")

	UiTbl.miscGroup:CheckBox("No Damage Indicators", function(bool)
		Settings.NoDamageIndicators = bool
	end, "NoDamageIndicators")
	
	UiTbl.miscGroup:CheckBox("Fast Upgrade", function(bool)
		Settings.FastUpgrade = bool
	end, "FastUpgrade")
	
	UiTbl.miscGroup:CheckBox("Fast Sprint", function(bool)
		Settings.FastSprint = bool
		local s = require(game.ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Settings"))
		s.SPRINT_WALKSPEED = bool and 56 or 28
	end, "FastSprint")
	
	UiTbl.miscGroup:CheckBox("Restart Dungeon", function(bool)
		Settings.RestartDungeon = bool
	end, "RestartDungeon").Click()

	UiTbl.miscGroup:CheckBox("Auto Feed Pet", function(bool)
		Settings.AutoFeed = bool

		local pets = require(game.ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Pets"))
		local items = require(game.ReplicatedStorage.Shared:WaitForChild("Items"))

		local profile = game.ReplicatedStorage:WaitForChild("Profiles"):WaitForChild(plr.Name)
		local inv = profile:WaitForChild("Inventory"):WaitForChild("Items")
		local equip = profile:WaitForChild("Equip"):WaitForChild("Pet")
		local foodNames = {"Strawberry", "Doughnut", "CakeSlice", "Sundae"}
		while Settings.AutoFeed do
			local pet = equip:GetChildren()[1]
			if pet then
				if items[pet.Name].Type == "Egg" and (not pet:FindFirstChild("XP") or pets:PetXPCurve(0) > pet.XP.Value)
				or items[pet.Name].Type == "Pet" and pet:FindFirstChild("Level") and pets:GetMaxLevel(pet) > pet.Level.Value then
					for i,v in pairs(foodNames) do
						if inv:FindFirstChild(v) then
							game.ReplicatedStorage.Shared.Pets:WaitForChild("FeedPet"):FireServer(inv[v])
							break
						end
					end
				end
			end
			wait()
		end
	end, "AutoFeed")

	UiTbl.miscGroup:CheckBox("Auto Bank", function(bool)
		Settings.AutoBank = bool
	end, "AutoBank")

	UiTbl.miscGroup:CheckBox("Auto Spin", function(bool)
		Settings.AutoSpin = bool

		while Settings.AutoSpin do
			local es = game.ReplicatedStorage.Shared:FindFirstChild("EventSpinner")
			if es then
				local remote = es:FindFirstChild("JoinQueue")
				if remote and not Settings.CanAutoSell then
					SecureFireServer(remote)
				end
			end
			wait(1)
		end
	end, "AutoSpin")

	local function EquipBestWeapon()
		if not Settings.EquipBestWeapon then
			return
		end
		local items = require(game.ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Items"))
		local combat = require(game.ReplicatedStorage.Shared.Combat)

		local profile = game.ReplicatedStorage:WaitForChild("Profiles"):WaitForChild(plr.Name)
		local current = profile:WaitForChild("Equip"):WaitForChild("Primary"):GetChildren()[1]
		local inv = profile:WaitForChild("Inventory"):WaitForChild("Items")

		local mostPowerWpn, mostPowerVal
		for i,v in pairs(inv:GetChildren()) do
			local data = items[v.Name]
			if data.Type == "Weapon" and v:FindFirstChild("Level") and v.Level.Value <= profile:WaitForChild("Level").Value then
				local power = combat:GetItemStats(v).Attack
				if power and (not mostPowerWpn or power > mostPowerVal) then
					mostPowerWpn = v
					mostPowerVal = power
				end
			end
		end

		local s, stats = pcall(combat.GetItemStats, combat, current)
		if mostPowerWpn and s and stats and stats.Attack and (not current or stats.Attack < mostPowerVal) then
			SecureFireServer(game.ReplicatedStorage.Shared.Inventory.EquipItem, mostPowerWpn, profile.Equip.Primary)
		end
	end
	UiTbl.miscGroup:CheckBox("Equip Best Weapon", function(bool)
		Settings.EquipBestWeapon = bool
		EquipBestWeapon()
	end, "EquipBestWeapon")

	UiTbl.instaKillSantaCb = UiTbl.tempGroup:CheckBox("Insta Kill Santa", function(bool, autoLoad)
		Settings.InstaKillSanta = bool

		if bool and not autoLoad then
			if messagebox("This will cause the boss to not drop holiday coins, only tickets.\nAre you sure you want to continue?", "[KiriotHub]", 0x00000004 + 0x00040000 + 0x00001000 + 0x00010000) == 7 then
				return UiTbl.instaKillSantaCb.Click()
			end
		end
	end, "InstaKillSanta")

	UiTbl.sellGui = NewUI:Tab("Sell & Delete")

	UiTbl.tiersGroup = UiTbl.sellGui:Group("Auto Sell Tiers")
	UiTbl.tiersGroup:Grid(UDim2.new(0,5,0,5), UDim2.new(0,70,0,25))

	UiTbl.autoSellGroup = UiTbl.sellGui:Group("Auto Sell Settings")
	UiTbl.autoDeleteGroup = UiTbl.sellGui:Group("Auto Delete")
	
	UiTbl.tiersGroup:CheckBox("Tier 5", function(bool)
		Settings.QuickSell.Tier5 = bool
	end, "Tier5"):SetLabelColor(Color3.fromRGB(244,130,48))
	
	UiTbl.tiersGroup:CheckBox("Tier 4", function(bool)
		Settings.QuickSell.Tier4 = bool
	end, "Tier4"):SetLabelColor(Color3.fromRGB(206,107,255))
	
	UiTbl.tiersGroup:CheckBox("Tier 3", function(bool)
		Settings.QuickSell.Tier3 = bool
	end, "Tier3"):SetLabelColor(Color3.fromRGB(102,135,255))
	
	UiTbl.tiersGroup:CheckBox("Tier 2", function(bool)
		Settings.QuickSell.Tier2 = bool
	end, "Tier2"):SetLabelColor(Color3.fromRGB(144,200,126))
	
	UiTbl.tiersGroup:CheckBox("Tier 1", function(bool)
		Settings.QuickSell.Tier1 = bool
	end, "Tier1")
	
	do
		if Settings.IsOpenWorld then
			local cb = UiTbl.autoSellGroup:CheckBox("Enabled\n(Not active in\nopen world)", function(bool)
				Settings.AutoSell = bool
			end, "AutoSell")
			cb:SetMultiLine()
			for i,v in pairs(cb.Components) do
				v.ChangeColor = false
			end
			cb.Components.Inner.ChangeColor = true
			cb.Components.Inner.DefaultColor = Color3.fromRGB(43, 47, 55)
		else
			UiTbl.autoSellGroup:CheckBox("Enabled", function(bool)
				Settings.AutoSell = bool
			end, "AutoSell")
		end
	end

	do
		local maxLevel = 130
		UiTbl.autoSellGroup:Slider({
			Min = 2,
			Max = maxLevel + 1,
			Default = maxLevel + 1
		}, function(val)
			if val == maxLevel + 1 then
				Settings.AutoSellBelowLvl = 999
				return "Below level: All"
			else
				Settings.AutoSellBelowLvl = val
				return "Below level: " .. val
			end
		end, "AutoSellBelowLvl")
	end

	UiTbl.autoSellGroup:Button("Sell Now!", function()
		local toSell = {}
		local items = require(game.ReplicatedStorage.Shared.Items)
		local inv = require(game.ReplicatedStorage.Shared.Inventory)
		
		local profile = game.ReplicatedStorage.Profiles[plr.Name]
		local myLevel = profile.Level.Value
		
		for i,v in pairs(profile.Inventory.Items:GetChildren()) do
			local data = items[v.Name]
			if data and (data.Type == "Weapon" or data.Type == "Armor") and Settings.QuickSell["Tier" .. inv:GetItemTier(v)] and not v:FindFirstChild("Locked") then
				local level = v:FindFirstChild("Level") --starter items don't have level
				if level and level.Value <= Settings.AutoSellBelowLvl then
					toSell[#toSell + 1] = v
				end
			end
		end
		SecureInvokeServer(game.ReplicatedStorage.Shared.Drops.SellItems, toSell)
	end)

	UiTbl.autoDeleteGroup:Label("Accessories")

	UiTbl.autoDeleteGroup:CheckBox("Enabled", function(bool)
		Settings.AutoDelete.Cosmetics.Enabled = bool
	end, "AutoDeleteCosmetics")

	UiTbl.autoDeleteGroup:CheckBox("Only Duplicates", function(bool)
		Settings.AutoDelete.Cosmetics.OnlyDupes = bool
	end, "AutoDeleteCosmeticsOnlyDupes").Click()

	UiTbl.autoDeleteGroup:CheckBox("Only Untradable", function(bool)
		Settings.AutoDelete.Cosmetics.OnlyUntradable = bool
	end, "AutoDeleteCosmeticsOnlyUntradable").Click()

	UiTbl.autoDeleteGroup:Label("Eggs")

	UiTbl.autoDeleteGroup:CheckBox("Enabled", function(bool)
		Settings.AutoDelete.Eggs.Enabled = bool
	end, "AutoDeleteEggs")

	UiTbl.autoDeleteGroup:CheckBox("Only Duplicates", function(bool)
		Settings.AutoDelete.Eggs.OnlyDupes = bool
	end, "AutoDeleteEggsOnlyDupes")

	UiTbl.autoDeleteGroup:Button("Quick Delete", function()
		local gui = NewUI:Popup("Confirm Deletion")
		local sf = gui:Group("These Items Will Be Deleted"):List({
			Height = 195
		})
		sf:Grid(UDim2.new(0,5,0,5), UDim2.new(0,58,0,58))

		local items = require(game.ReplicatedStorage.Shared.Items)
		local inv = require(game.ReplicatedStorage.Client.Gui):Get("Inventory")
		local profile = game.ReplicatedStorage.Profiles[plr.Name]

		local list = {}

		if Settings.AutoDelete.Cosmetics.Enabled then
			for i,v in pairs(profile.Inventory.Cosmetics:GetChildren()) do
				local data = items[v.Name]
				if data and data.Type == "Accessory" and (not Settings.AutoDelete.Cosmetics.OnlyUntradable or data.Untradeable) and (not Settings.AutoDelete.Cosmetics.OnlyDupes or profile.Inventory.Cosmetics:FindFirstChild(v.Name) ~= v) then
					table.insert(list, v)

					local new = inv:GetItemTile(v)
					new.Stars:Destroy()
					sf:AddCustomObject(new)
				end
			end
		end

		if Settings.AutoDelete.Eggs.Enabled then
			for i,v in pairs(profile.Inventory.Items:GetChildren()) do
				local data = items[v.Name]
				if data and data.Type == "Egg" and (not Settings.AutoDelete.Eggs.OnlyDupes or profile.Inventory.Items:FindFirstChild(v.Name) ~= v) then
					table.insert(list, v)

					local new = inv:GetItemTile(v)
					new.Stars:Destroy()
					sf:AddCustomObject(new)
				end
			end
		end

		gui:Button("Confirm", function()
			for i,v in pairs(list) do
				SecureFireServer(game.ReplicatedStorage.Shared.Inventory.DeleteItem, v)
				wait()
			end
			gui:Toggle()
			game.Debris:AddItem(gui.PrimaryFrame, 1)
		end)
		gui:Button("Cancel", function()
			gui:Toggle()
			game.Debris:AddItem(gui.PrimaryFrame, 1)
		end)
		gui:Toggle()
	end)
	
	UiTbl.tpsG = NewUI:Tab("Teleports", {
		Width = 188
	})
	UiTbl.lobbiesGroup = UiTbl.tpsG:Group("Lobbies")
	UiTbl.dungeonsGroup = UiTbl.tpsG:Group("Dungeons")

	local values = {"World 1 Lobby", "World 2 Lobby", "World 3 Lobby", "World 4 Lobby", "World 5 Lobby", "World 6 Lobby", "World 7 Lobby", "World 8 Lobby", "World 9 Lobby", "Marketplace", "PvP Arena", "Event Hub"}
	UiTbl.lobbiesGroup:Dropdown({
		Text = "Lobbies",
		Radio = false,
		Values = values
	}, function(val)
		local list = {13, 19, 20, 29, 31, 36, 40, 45, 49, 44, 39, 33} --setclipboard(require(game.ReplicatedStorage.Shared.Teleport):GetCurrentWorldID())
		require(game.ReplicatedStorage.Shared.Teleport):TeleportToWorld(plr, list[table.find(values, val)])
	end)

	--[[UiTbl.lobbiesGroup:Button("Event Lobby", function()
		require(game.ReplicatedStorage.Shared.Teleport):TeleportToWorld(plr, 33)
	end)]]

	DungeonsMap = {
		{Id = 17, Name = "Klaus Factory", World = "Event Dungeons"},
		{Id = 22, Name = "Halloween Event", World = "Event Dungeons"},

		--World 1--
		{Id = 1, Name = "Crabby Crusade", World = 1},
		{Id = 3, Name = "Scarecrow Defense", World = 1},
		{Id = 2, Name = "Dire Problem", World = 1},
		{Id = 4, Name = "Kingslayer", World = 1},
		--{Id = 5, Name = "Night of the Dead", World = 1},
		{Id = 6, Name = "Gravetower Dungeon", World = 1},
		
		--World 2--
		{Id = 11, Name = "Temple of Ruin", World = 2},
		{Id = 12, Name = "Mama Trauma", World = 2},
		{Id = 13, Name = "Volcano's Shadow", World = 2},
		{Id = 7, Name = "Volcano Dungeon", World = 2},
		
		--World 3--
		{Id = 14, Name = "Mountain Pass", World = 3},
		{Id = 15, Name = "Winter Cavern", World = 3},
		{Id = 16, Name = "Winter Dungeon", World = 3},
		
		--World 4--
		{Id = 20, Name = "Scrap Canyon", World = 4},
		{Id = 19, Name = "Deserted Burrowmine", World = 4},
		{Id = 18, Name = "Pyramid Dungeon", World = 4},

		--World 5--
		{Id = 24, Name = "Konoh Heartlands", World = 5},
		{Id = 21, Name = "Prison Tower", World = 5}, --:omegalul:

		--World 6--
		{Id = 25, Name = "Rough Waters", World = 6},
		{Id = 23, Name = "Atlantis Tower", World = 6},

		--World 7--
		{Id = 26, Name = "The Underworld", World = 7},
		{Id = 27, Name = "Mezuvian Tower", World = 7},

		--World 8--
		{Id = 30, Name = "Rescue In The Ruins", World = 8},
		{Id = 31, Name = "Ruin Rush", World = 8},
		{Id = 29, Name = "Oasis Tower", World = 8},

		--World 9--
		{Id = 32, Name = "Treetop Trouble", World = 9},
		{Id = 33, Name = "Aether Fortress", World = 9},
		{Id = 34, Name = "Aether Tower", World = 9}
	}
	do
		local worlds = {}
		for i,v in pairs(DungeonsMap) do
			if not worlds[v.World] then
				worlds[v.World] = {}
			end
			table.insert(worlds[v.World], v.Name)
		end

		for i,v in pairs(worlds) do
			UiTbl.dungeonsGroup:Dropdown({
				Text = type(i) == "number" and ("World " .. i) or i,
				Radio = false,
				Values = v
			}, function(val)
				for i,v in pairs(DungeonsMap) do
					if v.Name == val then
						SecureFireServer(game.ReplicatedStorage.Shared.Teleport[KH_CONSTANT("StartRaid")], v.Id)
					end
				end
			end)
		end
	end

	UiTbl.dungeonsGroup:Button("Dungeons Menu", function()
		task.spawn(function()
			syn_context_set(2)
			require(game.ReplicatedStorage.Client.Gui):Get("MissionSelect"):Open()
		end)
	end)

	UiTbl.dungeonsGroup:CheckBox("Auto Next Dungeon", function(bool)
		Settings.AutoNextDungeon = bool
	end, "AutoNextDungeon")

	UiTbl.dungeonsGroup:CheckBox("Include Difficulties", function(bool)
		Settings.IncludeDifficulties = bool
	end, "IncludeDifficulties")
	
	local isShown = false
	local ShowNextDungeonButton
	do
		local function GetDataById(id)
			local MissionData = require(game.ReplicatedStorage.Shared.Missions.MissionData)
			for i,v in pairs(MissionData) do
				if v.ID == id then
					return v
				end
			end
		end

		ShowNextDungeonButton = function(id)
			if isShown then
				return
			end
			isShown = true
			
			debugwarn("Showing for",id)
			
			local currLvl = game.ReplicatedStorage.Profiles[plr.Name].Level
			local CurrentMission = GetDataById(id)

			if not CurrentMission then
				debugwarn("Can't find the current mission")
				return
			end
			
			local list = {}
			for i,v in pairs(DungeonsMap) do
				list[i] = v.Id
			end
			local nextMissionData = GetDataById(list[table.find(list, CurrentMission.ID)+1])

			if not nextMissionData then --last dungeon
				return
			end
			
			local nextId = nextMissionData.ID
			local levelReq = nextMissionData.LevelRequirement
			
			debugwarn("Next id:", nextId)
			
			UiTbl.nextDungeonBtn = UiTbl.dungeonsGroup:Button("Next Dungeon", function()
				local nextDifficulty
				if Settings.IncludeDifficulties and Settings.CurrentMissionDifficulty and CurrentMission.difficulties then
					local diffs = {}
					for i,v in pairs(CurrentMission.difficulties) do
						table.insert(diffs, v)
					end
					table.sort(diffs, function(a,b) --some dungeons have ex. {1,2,nil,nil,5} in their difficulties data
						return a.id < b.id
					end)

					local current = CurrentMission.difficulties[Settings.CurrentMissionDifficulty]
					nextDifficulty = diffs[table.find(diffs, current) + 1]
				end

				if nextDifficulty then
					nextId = id
					nextDifficulty = nextDifficulty.id
				end
				if nextDifficulty or currLvl.Value >= levelReq then
					SecureFireServer(game.ReplicatedStorage.Shared.Teleport.StartRaid, nextId, nextDifficulty)
				else
					return false
				end
			end)
			
			local function CheckLevel()
				if currLvl.Value >= levelReq then
					UiTbl.nextDungeonBtn:SetButtonColor(Color3.fromRGB(29,207,115))
				else
					UiTbl.nextDungeonBtn:SetButtonColor(Color3.fromRGB(200,0,0))
				end
			end
			CheckLevel()
			currLvl.Changed:Connect(CheckLevel)
		end
	end
	
	UiTbl.miscG = NewUI:Tab("Misc")
	UiTbl.guisGroup = UiTbl.miscG:Group("Guis")
	UiTbl.statsGroup = UiTbl.miscG:Group("Stats")

	UiTbl.guisGroup:CheckBox("Auto Hide UI", function(bool, autoLoad)
		if bool and autoLoad then
			NewUI.Gui.Enabled = false
		end
	end, "AutoHideUI")
	
	UiTbl.guisGroup:Button("Open Bank", function()
		task.spawn(function()
			syn_context_set(2)
			require(game.ReplicatedStorage.Client.Gui):Get("Bank"):Open()
		end)
	end)
	
	UiTbl.guisGroup:Button("Open Sell", function()
		task.spawn(function()
			syn_context_set(2)
			require(game.ReplicatedStorage.Client.Gui):Get("Sell"):Open()
		end)
	end)
	
	UiTbl.guisGroup:Button("Open Upgrade", function()
		task.spawn(function()
			syn_context_set(2)
			require(game.ReplicatedStorage.Client.Gui):Get("ItemUpgrade"):Open()
		end)
	end)

	UiTbl.guisGroup:Button("Open Zero Altar", function()
		task.spawn(function()
			syn_context_set(2)
			require(game.ReplicatedStorage.Client.Gui):Get("Fusion"):Open()
		end)
	end)

	UiTbl.guisGroup:Button("Open Wheel", function()
		task.spawn(function()
			syn_context_set(2)
			require(game.ReplicatedStorage.Client.Gui):Get("EventSpinner"):Open()
		end)
	end)

	UiTbl.guisGroup:Button("Open All Markets", function()
		spawn(function()
			syn_context_set(2)
			local shop = require(game.ReplicatedStorage.Client.Gui):Get("Shop")
			local func = getfenv(shop.Open).BuildShop
			
			pcall(shop.Open, shop, game)
			for i,v in pairs(getupvalue(func, 1)) do
				v:Destroy()
			end
			for i,v in pairs(getupvalue(func, 2)) do
				v:Disconnect()
			end

			local list = {}
			local conns = {}
			local profiles = game.ReplicatedStorage:WaitForChild("Profiles")
			for i,p in pairs(game.Players:GetPlayers()) do
				local plrShop = profiles:FindFirstChild(p.Name) and profiles[p.Name]:FindFirstChild("SellShop")
				if plrShop and plrShop:FindFirstChild("Active") and plrShop.Active.Value then
					setupvalue(func, 1, {})
					setupvalue(func, 2, {})
					func(p)
					for i,v in pairs(getupvalue(func, 1)) do
						v.Title.Text = v.Title.Text .. " (" .. p.Name .. ")"
						v.Title.Overlay.Text = v.Title.Text
						table.insert(list, v)
					end
					for i,v in pairs(getupvalue(func, 2)) do
						table.insert(conns, v)
					end
				end
			end

			if Settings.MarketFilter and Settings.MarketFilter ~= "" then
				for i,v in pairs(list) do
					if not v.Title.Text:lower():find(Settings.MarketFilter:lower()) then
						v:Destroy()
					end
				end
			end

			setupvalue(func, 1, list)
			setupvalue(func, 2, conns)
			getupvalue(shop.Init, 1).Title.Text = "All Shops"
			getupvalue(shop.Init, 1).Title.Overlay.Text = "All Shops"
		end)
	end)

	UiTbl.guisGroup:TextBox({
		PlaceholderText = "Market Filter"
	}, function(text, enter, input, autoLoad)
		Settings.MarketFilter = text
	end, "MarketFilter") 

	UiTbl.goldStatLb = UiTbl.statsGroup:Label("Gold Earned: 0")
	UiTbl.xpStatLb = UiTbl.statsGroup:Label("XP Earned: 0")
	
	Enter.Visible = false
	KeyTB.Visible = false
	
	Main:TweenSizeAndPosition(UDim2.new(0,346,0,154), UDim2.new(0,191,0,138),nil,nil,0.4,true, function()
		NewUI.Gui.Parent = game.CoreGui
		Gui:Destroy()
	end)
	
	--actual stuff--
	cam = game.ReplicatedStorage:WaitForChild(KH_CONSTANT("Client")):WaitForChild("Camera")
	
	--Skipping Cutscenes--
	spawn(function()
		wait(1) --stupid game cant WaitForChild properly, and I need the declaration in the main scope cuz constant
		cam = require(cam)
		if not is_synapse_function(cam.BeginCutscene) then
			local old = cam.BeginCutscene
			cam.BeginCutscene = function(...)
				if Settings.SkipCutscenes then
					return
				end
				return old(...)
			end
		end
	end)
	
	--AutoSell--
	Settings.CanAutoSell = false
	profile = game:GetService("ReplicatedStorage"):WaitForChild("Profiles"):WaitForChild(plr.Name)
	profile:WaitForChild("Inventory"):WaitForChild("Items").ChildAdded:Connect(function(c)
		local items = require(game.ReplicatedStorage.Shared.Items)
		local inv = require(game.ReplicatedStorage.Shared.Inventory)
		local myLevel = profile.Level.Value

		local soldOrDeleted = false
		local cd = not Settings.IsOpenWorld and tostring(game.ReplicatedStorage:WaitForChild("ActiveMission").Value)
		local data = items[c.Name]
		if not Settings.IsOpenWorld and Settings.CanAutoSell and Settings.AutoSell and (data.Type == "Weapon" or data.Type == "Armor") and Settings.QuickSell["Tier" .. inv:GetItemTier(c)] and not c:FindFirstChild("Locked") then
			local level = c:WaitForChild("Level").Value
			if level < Settings.AutoSellBelowLvl then
				wait()
				debugprint("selling", c)
				SecureInvokeServer(game.ReplicatedStorage.Shared.Drops.SellItems, {c})
				soldOrDeleted = true
			end
		end

		--delete eggs and dyes--
		if Settings.AutoDelete.Eggs.Enabled then
			local data = items[c.Name]
			if data.Type == "Egg" and (not Settings.AutoDelete.Eggs.OnlyDupes or profile.Inventory.Items:FindFirstChild(c.Name) ~= c) then
				wait()
				SecureFireServer(game.ReplicatedStorage.Shared.Inventory.DeleteItem, c)
				debugprint("deleted", c.Name)
				soldOrDeleted = true
			end
		end

		if Settings.AutoBank and not soldOrDeleted and inv:GetRemainingSpace(profile.Inventory) == 0 then
			SecureFireServer(game.ReplicatedStorage.Shared.Bank.TransferToBank, c, 1)
			debugprint("transferred to bank", c)
		end

		if not soldOrDeleted then
			wait()
			EquipBestWeapon()
		end
	end)
	profile.Inventory:WaitForChild("Cosmetics").ChildAdded:Connect(function(c)
		local items = require(game.ReplicatedStorage.Shared.Items)

		if Settings.AutoDelete.Cosmetics.Enabled then
			local data = items[c.Name]
			if data and data.Type == "Accessory" and (not Settings.AutoDelete.Cosmetics.OnlyUntradable or data.Untradeable) and (not Settings.AutoDelete.Cosmetics.OnlyDupes or profile.Inventory.Cosmetics:FindFirstChild(c.Name) ~= c) then
				wait()
				SecureFireServer(game.ReplicatedStorage.Shared.Inventory.DeleteItem, c)
				debugprint("deleted", c.Name)
			end
		end
	end)

	coroutine.wrap(function()
		local xp = profile:WaitForChild("Exp")
		local gold = profile:WaitForChild("Currency"):WaitForChild("Gold")

		local xpCount, goldCount = 0, 0
		local lastXp, lastGold = xp.Value, gold.Value
		debugprint("init stats", lastXp, lastGold)

		xp.Changed:Connect(function(newXp)
			if newXp > lastXp then
				local diff = newXp - lastXp
				xpCount = xpCount + diff
			else --in case of level up, don't add the difference but rather the xp from 0
				xpCount = xpCount + newXp
			end
			lastXp = newXp
			UiTbl.xpStatLb.LabelObj.Text = "XP Earned: " .. xpCount
		end)

		gold.Changed:Connect(function(newGold)
			if newGold > lastGold then
				local diff = newGold - lastGold
				goldCount = goldCount + diff
			end
			--if the difference is negative it means gold was spent, in which case do nothing
			lastGold = newGold
			UiTbl.goldStatLb.LabelObj.Text = "Gold Earned: " .. goldCount
		end)
	end)()
	
	--Killaura--
	--[[
		Paladin - GetInCone 10 height, 16 or 21 depth, 25 or 45 radius (light sword buffs)
		Archer - GetInRadius 50 height (seems a lot smaller for primary attack)
		Berserker - GetInCone 10 height, 16 depth, 45 radius
		Dragoon - GetInCone 10 height, 14 depth, 25 radius
		Demon - GetInCone 10 height, 14 depth, 25 radius
		DualWielder - GetInCone 10 height, 14 depth, 25 radius
		Guardian - GetInCone 1- height, 16 depth, 45 radius
		Swordmaster - GetInCone 10 height, 14 depth, 25 radius
		Defender - GetInCone 10 height, 14 depth, 25 radius

		mages have no limit?
	]]
	local function InitClass()
		attackTypes = {}
		passiveSkills = {}
		Settings.NonGroundClass = false
		local Class = profile:WaitForChild(KH_CONSTANT("Class")).Value
		if Class == "Swordmaster" then
			for i=1,6 do
				table.insert(attackTypes, {Name = "Swordmaster" .. i, Cooldown = 0.3})
			end
			for i=1,5 do
				table.insert(attackTypes, {Name = "CrescentStrike" .. i, Cooldown = 5})
			end
			table.insert(attackTypes, {Name = "Leap", Cooldown = 8})
		elseif Class == "Mage" then --Arcane Mage
			Settings.NonGroundClass = true
			for i=1,3 do
				table.insert(attackTypes, {Name = "Mage" .. i, Cooldown = 0.3})
			end
			--table.insert(attackTypes, {Name = "ArcaneBlastAOE", Cooldown = 5})
			--table.insert(attackTypes, {Name = "ArcaneBlast", Cooldown = 0})
			--[[for i=1,12 do
				table.insert(attackTypes, {Name = "ArcaneWave" .. i, Cooldown = 8})
			end]]
		elseif Class == "Defender" then
			for i=1,5 do
				table.insert(attackTypes, {Name = "Defender" .. i, Cooldown = 0.3})
			end
			table.insert(attackTypes, {Name = "Groundbreaker", Cooldown = 5})
			for i=1,4 do
				table.insert(attackTypes, {Name = "Spin" .. i, Cooldown = 8})
			end
		elseif Class == "DualWielder" then
			for i=1,10 do
				table.insert(attackTypes, {Name = "DualWield" .. i, Cooldown = 0.7})
			end
			table.insert(attackTypes, {Name = "DashStrike", Cooldown = 6})
			for i=1,10 do
				table.insert(attackTypes, {Name = "CrossSlash" .. i, Cooldown = 8})
			end
			--[[for i=1,8 do
				table.insert(attackTypes, {Name = "DualWieldUltimateHit" .. i, Cooldown = 10})
			end
			for i=1,16 do
				table.insert(attackTypes, {Name = "DualWieldUltimateSword" .. i, Cooldown = 10})
			end
			table.insert(attackTypes, {Name = "DualWieldUltimateSlam", Cooldown = 10})
			for i=1,3 do
				table.insert(attackTypes, {Name = "DualWieldUltimateSlam" .. i, Cooldown = 10})
			end]]

			local skills = game:GetService("ReplicatedStorage").Shared
			:WaitForChild("Combat"):WaitForChild("Skillsets")
			:WaitForChild("DualWielder")

			table.insert(passiveSkills, {Skill = skills:WaitForChild("AttackBuff"), Cooldown = 1})
		elseif Class == "IcefireMage" then --Elementalist
			Settings.NonGroundClass = true
			for i=1,3 do
				table.insert(attackTypes, {Name = "IcefireMage" .. i, Cooldown = 0.3})
			end
			for i=1,5 do
				table.insert(attackTypes, {Name = "IcySpikes" .. i, Cooldown = 6})
			end
			table.insert(attackTypes, {Name = "IcefireMageFireball", Cooldown = 10})
			table.insert(attackTypes, {Name = "IcefireMageFireballBlast", Cooldown = 10})
			table.insert(attackTypes, {Name = "IcefireMageFireballFrost", Cooldown = 5})
			for i=1,5 do
				table.insert(attackTypes, {Name = "LightningStrike" .. i, Cooldown = 15})
			end
		elseif Class == "MageOfLight" then
			Settings.NonGroundClass = true
			table.insert(attackTypes, {Name = "MageOfLight", Cooldown = 0.25})
			table.insert(attackTypes, {Name = "MageOfLightBlast", Cooldown = 0.3})
			table.insert(attackTypes, {Name = "MageOfLightCharged", Cooldown = 0.3})
			table.insert(attackTypes, {Name = "MageOfLightBlastCharged", Cooldown = 0.3})
			
			local skills = game:GetService("ReplicatedStorage").Shared
			:WaitForChild("Combat"):WaitForChild("Skillsets")
			:WaitForChild("MageOfLight")
			
			--local myLevel = profile.Level.Value
			--local data = require(game.ReplicatedStorage.Shared:WaitForChild("Skills"))
			
			--if myLevel >= data.IcefireMage.Skill1.LevelRequirement then
				table.insert(passiveSkills, {Skill = skills:WaitForChild("HealCircle", 7), Cooldown = 9})
			--end

			--the barrier skill can be used n times every 15 seconds, where n is the amount of players in the server
			local lastUse
			local uses = 0
			table.insert(passiveSkills, {Skill = skills:WaitForChild("Barrier", 7), Cooldown = 0, Callback = function(self)
				if Settings.IsOpenWorld then --don't give barrier to everyone in the open world LOL
					return
				end
				if lastUse and tick() - lastUse <= 15 and uses >= #game.Players:GetPlayers() then
					return
				end

				local list = {}
				for i,v in pairs(game.Players:GetPlayers()) do
					local hp = v.Character and v.Character:FindFirstChild("HealthProperties")
					if hp and hp:FindFirstChild("BarrierHealth") and hp.BarrierHealth.Value <= 0 and hp:FindFirstChild("Health") and hp.Health.Value > 0 then
						table.insert(list, v)
					end
				end

				if #list > 0 then
					if not lastUse or tick() - lastUse > 15 then
						lastUse = tick()
						uses = 1
					else
						uses = uses + 1
					end
				end
				for i,v in pairs(list) do
					debugwarn("actually using barrier on", v)
					SecureFireServer(self.Skill, v)
				end
			end})
		elseif Class == "Guardian" then
			for i=1,4 do
				table.insert(attackTypes, {Name = "Guardian" .. i, Cooldown = 0.6})
			end
			for i=1,5 do
				table.insert(attackTypes, {Name = "RockSpikes" .. i, Cooldown = 6})
			end
			for i=1,16 do
				table.insert(attackTypes, {Name = "SlashFury" .. i, Cooldown = 8})
			end
			for i=1,12 do
				table.insert(attackTypes, {Name = "SwordPrison" .. i, Cooldown = 10})
			end
		elseif Class == "Berserker" then
			for i=1,6 do
				table.insert(attackTypes, {Name = "Berserker" .. i, Cooldown = 0.5})
			end
			for i=1,8 do
				table.insert(attackTypes, {Name = "GigaSpin" .. i, Cooldown = 7})
			end
			table.insert(attackTypes, {Name = "AggroSlam", Cooldown = 5})
			for i=1,2 do
				table.insert(attackTypes, {Name = "Fissure" .. i, Cooldown = 10})
			end
			for i=1,8 do
				table.insert(attackTypes, {Name = "FissureErupt" .. i, Cooldown = 10})
			end
		elseif Class == "Paladin" then
			for i=1,4 do
				table.insert(attackTypes, {Name = "Paladin" .. i, Cooldown = 0.5})
			end
			for i=1,4 do
				table.insert(attackTypes, {Name = "LightPaladin" .. i, Cooldown = 0.5})
			end
			for i=1,2 do
				table.insert(attackTypes, {Name = "LightThrust" .. i, Cooldown = 8})
			end

			local skills = game:GetService("ReplicatedStorage").Shared:WaitForChild("Combat"):WaitForChild("Skillsets"):WaitForChild("Paladin")
			table.insert(passiveSkills, {Skill = skills:WaitForChild("GuildedLight"), Cooldown = 15})
		elseif Class == "Demon" then
			for i=1,27 do
				table.insert(attackTypes, {Name = "Demon" .. i, Cooldown = 3.5, KeyName = "Monster Slash"})
			end
			for i=1,9 do
				table.insert(attackTypes, {Name = "DemonDPS" .. i, Cooldown = 3.5, KeyName = "Monster Slash"})
			end
			--[[for i=1,8 do
				table.insert(attackTypes, {Name = "ScytheThrow" .. i, Cooldown = 1, KeyName = "Scythe Throw"})
			end
			for i=1,3 do
				table.insert(attackTypes, {Name = "ScytheThrowDPS" .. i, Cooldown = 1, KeyName = "Scythe Throw"})
			end]]
			--DemonSoulAOE and DemonSoulDPS could be useful but they're also auto triggered by the localscript so that'd have to be blocked first
			table.insert(attackTypes, {Name = KH_CONSTANT("DemonLifeStealDPS"), Cooldown = 8, KeyName = "Life Steal"})
			--table.insert(attackTypes, {Name = "DemonLifeStealAOE", Cooldown = 8})
		elseif Class == "Dragoon" then
			for i=1,6 do
				table.insert(attackTypes, {Name = "Dragoon" .. i, Cooldown = 0.4})
			end
			for i=1,10 do
				table.insert(attackTypes, {Name = "DragoonCross" .. i, Cooldown = 6})
			end
			for i=1,5 do
				table.insert(attackTypes, {Name = "MultiStrike" .. i, Cooldown = 6})
			end
			table.insert(attackTypes, {Name = "DragoonFall", Cooldown = 8})
			for i=1,3 do
				table.insert(attackTypes, {Name = "MultiStrikeDragon" .. i, Cooldown = 6})
			end
			--table.insert(attackTypes, {Name = "DragoonUltimate", Cooldown = 1})
			--[[for i=1,6 do
				table.insert(attackTypes, {Name = "UltimateDragon" .. i, Cooldown = 6})
			end]]
		elseif Class == "Archer" then
			Settings.NonGroundClass = true
			table.insert(attackTypes, {Name = "Archer", Cooldown = 0.4})
			for i=1,9 do
				table.insert(attackTypes, {Name = "PiercingArrow" .. i, Cooldown = 5})
			end
			--[[for i=1,6 do --caused kicks for some reason
				table.insert(attackTypes, {Name = "HeavenlySword" .. i, Cooldown = 1})
			end]]
			table.insert(attackTypes, {Name = "SpiritBomb", Cooldown = 10})
			for i=1,8 do
				table.insert(attackTypes, {Name = "MortarStrike" .. i, Cooldown = 11})
			end
			--BackstepAttack could be used but it's triggered automatically on dodge
		elseif Class == "Warlord" then
			for i=1,4 do
				table.insert(attackTypes, {Name = "Warlord" .. i, Cooldown = 0})
			end
			table.insert(attackTypes, {Name = "BlockingWarlord", Cooldown = 4})
			for i=1,2 do
				table.insert(attackTypes, {Name = "Piledriver" .. i, Cooldown = 6})
			end
			table.insert(attackTypes, {Name = "ChainsOfWar", Cooldown = 13})
			for i=1,5 do
				table.insert(attackTypes, {Name = "WarlordUltimate" .. i, Cooldown = 30}) --unsure, 5 kicks after a while in 7-1, 10 doesn't but does kick other people
			end
		elseif Class == "Summoner" then
			Settings.NonGroundClass = true
			for i=1,4 do
				table.insert(attackTypes, {Name = "Summoner" .. i, Cooldown = 0.85})
			end
			for i=1,5 do
				table.insert(attackTypes, {Name = "SoulHarvest" .. i, Cooldown = 1.9})
			end

			local skills = game:GetService("ReplicatedStorage").Shared:WaitForChild("Combat"):WaitForChild("Skillsets"):WaitForChild("Summoner")
			table.insert(passiveSkills, {Skill = skills:WaitForChild("Summon"), Cooldown = 6})
			--table.insert(passiveSkills, {Skill = skills:WaitForChild("ExplodeSummons"), Cooldown = 3})
		end

		if isDebug then
			local data = require(game.ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Skills"))[Class]
			for i,v in pairs(attackTypes) do
				local name = v.KeyName
				if name then
					v.KeyName = nil
					for i,w in pairs(data) do
						if w.Name == name then
							v.KeyName = i
							break
						end
					end
				end
			end
		end

		if isSnitch then
			attackTypes = table.create(30, {
				Name = attackTypes[1].Name,
				Cooldown = 0
			})
		end
		table.sort(attackTypes, function(a,b)
			return a.Cooldown > b.Cooldown
		end)
	end
	InitClass()
	profile.Class.Changed:Connect(InitClass)

	IsBoss = function(mob)
		if mob.Name:find("BOSSKrakenArm") then
			return false
		end

		if mob.Name:find("BOSS") then
			return true
		end

		if mob.Name == "HadesCerberus" then
			return false --bad workaround for 2 bosses at once and the 1st being invincible until you defeat the 2nd
		end

		local module = game.ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Mobs"):WaitForChild("Mobs"):FindFirstChild(mob.Name)
		if module then
			local tag = require(module).BossTag
			if tag and tag:sub(1,4) ~= "Mini" then
				return true
			end
		end
		return false
	end
	
	local SpecialObjects = {}
	local function ShouldIgnoreMob(mob)
		if mob.Name:find("SummonerSummon") then
			return true
		end
		if not Settings.IsTower and mob.Name == "Sentry" and mob:FindFirstChild("FromSpawnPart") and mob.FromSpawnPart.Value and workspace:FindFirstChild("MissionObjects") and workspace.MissionObjects:IsAncestorOf(mob.FromSpawnPart.Value) then
			return true
		end
		return false
	end
	KH_OBFUSCATE([[
		local plr, Settings, SpecialObjects, IsBoss, ShouldIgnoreMob = ...
		
		for i,v in pairs(workspace:GetDescendants()) do
			if v.Name == "HealthProperties" and not workspace.Mobs:IsAncestorOf(v) and not workspace.Characters:IsAncestorOf(v) and not v.Parent:FindFirstChild("IgnorePlayerHits") and not v:FindFirstAncestor("TargetDummies") then
				SpecialObjects[#SpecialObjects + 1] = v.Parent
			end
		end
		
		workspace.DescendantAdded:Connect(function(v)
			if v.Name == "HealthProperties" and not workspace.Mobs:IsAncestorOf(v) and not workspace.Characters:IsAncestorOf(v) and not v.Parent:FindFirstChild("IgnorePlayerHits") and not v:FindFirstAncestor("TargetDummies") then
				SpecialObjects[#SpecialObjects + 1] = v.Parent
			end
		end)
			
		getgenv()[""] = function(bool)
			if not plr.Character or not plr.Character.PrimaryPart then
				return
			end
			
			local t = {}
			local hrp = plr.Character.PrimaryPart
			
			for i,v in pairs(SpecialObjects) do
				local hp = v:FindFirstChild("HealthProperties")
				if v.Parent and hp and hp:FindFirstChild("Health") and hp.Health.Value > 0 then
					t[#t + 1] = v
					if bool then
						return v.PrimaryPart or v:FindFirstChildWhichIsA("BasePart", true), v
					end
				end
			end
			
			local count = 0
			for i,v in pairs(workspace.Mobs:GetChildren()) do
				if not ShouldIgnoreMob(v) then
					if not IsBoss(v) then
						count = count + 1
					elseif bool and v.Name == "BOSSAnubis" then
						return v.PrimaryPart, v
					end
				end
			end
			
			local closestMob, closestModel, closestPos
			for i,v in pairs(workspace.Mobs:GetChildren()) do
				local mob = (v:FindFirstChild("Subcollider") or v).PrimaryPart
				if mob and not ShouldIgnoreMob(v) then
					local dist = (hrp.Position - mob.Position).magnitude
					if dist < Settings.KillauraRange then
						t[#t + 1] = v
					end
					if bool and (not closestMob or dist < closestPos) and not (IsBoss(v) and count > 1 and not Settings.IsOpenWorld) then
						local hp = v.HealthProperties.Health.Value
						if hp > 0 then --and dist < 100000 then
							closestMob = mob
							closestModel = v
							closestPos = dist
						end
					end
				end
			end
			
			if bool then
				return closestMob, closestModel
			end
			return t
		end
	]], plr, Settings, SpecialObjects, IsBoss, ShouldIgnoreMob)
	
	while type(getgenv()[""]) ~= "function" do
		wait()
	end
	GetMobs = getgenv()[""]
	getgenv()[""] = nil
	
	--Hatch Egg in dungeons--
	spawn(function()
		local pet = game.ReplicatedStorage.Profiles[plr.Name].Equip.Pet:GetChildren()[1]
		if pet and pet.Name:find("Egg") and pet:FindFirstChild("XP") and pet.XP.Value >= 30 and plr.PlayerGui.HatchEgg.HatchEgg.Visible == false then
			plr.PlayerGui.HatchEgg.HatchEgg.Visible = true
			plr.PlayerGui.HatchEgg.HatchEgg.Hatch.MouseButton1Click:Connect(function()
				plr.PlayerGui.HatchEgg.HatchEgg.Visible = false
				SecureFireServer(game.ReplicatedStorage.Shared.Pets.Hatch, plr.Character.Head.Position)
			end)
		end
	end)
	
	--Unequip Pet in dungeons--
	local missions = game.ReplicatedStorage.Shared.Missions
	spawn(function()
		local GetOptions = getfenv(require(game.ReplicatedStorage.Client.Gui.GuiScripts.Inventory).Init).GetOptions
		local missionsModule = require(missions)
		
		local old = missionsModule.IsMissionPlace
		missionsModule.IsMissionPlace = function(...)
			if debug.getinfo(2).func == GetOptions or debug.validlevel(3) and debug.getinfo(3).name == "BuildFrame" then
				return false
			end
			return old(...)
		end
	end)
	
	--Auto Upgrade--
	spawn(function()
		local iu = require(game.ReplicatedStorage.Shared.ItemUpgrade)
		local UpgradedItem
		
		local old = iu.UpgradeItem
		iu.UpgradeItem = function(...)
			local args = {...}
			local item = args[3]
			
			if not Settings.FastUpgrade then
				UpgradedItem = nil
				return old(...)
			end
			
			debugprint("Item is being upgraded")
			
			UpgradedItem = item
			return old(...)
		end
		
		game.ReplicatedStorage.Shared.ItemUpgrade.Upgrade.OnClientEvent:Connect(function(s, _chance, _hit)
			if UpgradedItem then
				debugprint("Event received")
				local curr = UpgradedItem:FindFirstChild("Upgrade")
				curr = curr and curr.Value or 0
				
				local max = UpgradedItem:FindFirstChild("UpgradeLimit")
				if not max then
					--something's wrong
					debugwarn("No max?")
					return
				end
				max = max.Value
				
				if curr < max then
					debugprint("Upgrading..")
					old(iu, "idk", UpgradedItem)
				else
					debugprint("Fully upgraded!")
					UpgradedItem = nil
				end
			end
		end)
	end)
	
	--Next Dungeon Button--
	spawn(function()
		local CurrentDungeon = game.ReplicatedStorage:FindFirstChild("ActiveMission")
		if not CurrentDungeon then
			local ev
			ev = game.ReplicatedStorage.ChildAdded:Connect(function(c)
				if c.Name == "ActiveMission" then
					ev:Disconnect()
					Settings.CurrentMissionId = c.Value
					if not Settings.IsTower and game.PlaceId ~= Dungeons.HolidayEvent then
						Settings.CurrentMissionDifficulty = game.TeleportService:GetLocalPlayerTeleportData().difficultyId or SecureInvokeServer(game.ReplicatedStorage.Shared.Missions.GetDifficulty)
						--note: the fucking remote is unreliable and ex. returns 1 for the santa dungeon, even though it has no difficulty and tp data reflects that properly
					end
					ShowNextDungeonButton(c.Value)
				end
			end)
		else
			Settings.CurrentMissionId = CurrentDungeon.Value
			if not Settings.IsTower and game.PlaceId ~= Dungeons.HolidayEvent then
				Settings.CurrentMissionDifficulty = game.TeleportService:GetLocalPlayerTeleportData().difficultyId or SecureInvokeServer(game.ReplicatedStorage.Shared.Missions.GetDifficulty)
			end
			ShowNextDungeonButton(CurrentDungeon.Value)
		end
	end)
	
	--AutoFarm--
	
	Actions = require(game.ReplicatedStorage:WaitForChild("Client"):WaitForChild("Actions"))
	if not is_synapse_function(Actions.UseSkill) then
		local old = Actions.UseSkill
		Actions.UseSkill = function(self, skill, ...)
			if Settings.Killaura then
				return
			end
			return old(self, skill, ...)
		end
	end

	missions.MissionFinished.OnClientEvent:Connect(function()
		if Settings.Autofarm then
			wait(3)
			
			Settings.CanAutoSell = true
			
			SecureInvokeServer(missions.GetMissionPrize)
			if game:GetService("MarketplaceService"):UserOwnsGamePassAsync(plr.UserId, 8136250) then
				SecureInvokeServer(missions.GetMissionPrize)
			end
			--[[local rewards = {}
			for i=1,2 do --in case of VIP
				table.insert(rewards, {SecureInvokeServer(missions.GetMissionPrize)})
			end
			require(missions).GetMissionPrize = function()
				return unpack(table.remove(rewards, 1))
			end]]
			local name = "A Cute Replacement Carrot UwU"
			local p = game:GetObjects("rbxassetid://1696675")[1]
			p.Name = name
			p.PrimaryPart = p.Head
			require(missions).GetMissionPrize = function()
				return p
			end
			local inv = require(game.ReplicatedStorage.Shared.Inventory)
			local GetItemTier = inv[KH_CONSTANT("GetItemTier")]
			inv.GetItemTier = function(self, item)
				if item == p then
					return 5
				end
				return GetItemTier(self, item)
			end
			require(game.ReplicatedStorage.Shared.Items)[name] = {
				Level = 69,
				[KH_CONSTANT("DisplayKey")] = name
			}
			local mp = require(game.ReplicatedStorage.Shared.ModelProvider)
			local GetModel = mp.GetModel
			mp.GetModel = function(self, name)
				if name == name then
					return p:Clone()
				end
				return GetModel(self, name)
			end
			
			wait(1)

			if Settings.AutoNextDungeon then
				if UiTbl.nextDungeonBtn.Callback() == false and Settings.RestartDungeon then
					wait(0.5)
					local force = Settings.IsTower
					RestartDungeon(force)
				end
			elseif Settings.RestartDungeon then --note to self: DO NOT call RestartDungeon after calling Next Dungeon, or else the game spits out the guid kick
				local force = Settings.IsTower
				RestartDungeon(force)
			end
		elseif Settings.AutoNextDungeon then
			UiTbl.nextDungeonBtn.Callback()
		end
	end)
	
	attackRemote = game.ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Combat"):WaitForChild("Attack")
	
	local ProgressTriggers = {}
	TriggerProgress = function()
		if isSnitch then
			return
		end
		for i,v in pairs(ProgressTriggers) do
			if game:IsAncestorOf(v) then
				if v:FindFirstChildOfClass(KH_CONSTANT("TouchTransmitter")) then
					TriggerTouch(v)
					--debugwarn("Triggering",v:GetFullName(),#ProgressTriggers)
				end
			else
				ProgressTriggers[i] = nil
			end
		end
	end
	
	local WhitelistedParts = {
		TownTalkPart = true,
		CaveTrigger = true,
		ElevatorStart = true,
		WaveStarter = true,
	}
	local BlacklistedParts = {
		MushroomTrigger = true,
		MushroomGroundTrigger = true,
		Shaft = true,
		DamageTrigger = true,
		LavaTrigger = true,
		Collider = true,
		WallsTrigger = true,
		WallsFinalTrigger = true,
		CaveTrigger = Dungeons.MountainPass,
		TriggerFloor = true,
		BoundingBox = Dungeons.Tower2,
	}
	local BlacklistedParents = {
		Model = true,
		RollingBoulder = true, --w1m2
		RollingCoal = true, --holiday event
	}
	local BlacklistedAncestors = {
		DamageDroppers = true,
		FallAreas = true,
		TubeMarkers = true,
	}
	
	local function IsValid(obj, descAdded)
		if obj.Parent.Name == KH_CONSTANT("Collider") then --cages, crystals, etc.
			local model = obj.Parent.Parent
			if model and model.Parent == workspace then
				if not BlacklistedParents[model.Name] then
					return true
				else
					return false
				end
			end
		end
		for i,v in pairs(BlacklistedAncestors) do
			if obj:FindFirstAncestor(i) then
				wait()
				obj.Parent:Destroy()
				return false
			end
		end
		local bl = BlacklistedParts[obj.Parent.Name]
		if bl == true or bl == game.PlaceId then
			return false
		end
		if obj.Parent.Name:find("Trigger") then
			return true
		end
		if WhitelistedParts[obj.Parent.Name] then
			return true
		end
		if descAdded and obj.Parent.Parent.ClassName == "Model" then
			return true
		end
		return false
	end
	for i,v in pairs(workspace:GetDescendants()) do
		if v.ClassName == "TouchTransmitter" and IsValid(v) then
			ProgressTriggers[#ProgressTriggers + 1] = v.Parent
		end
	end
	
	do
		local fix3ds = loadstring([[
			local IsValid, ProgressTriggers = ...

			return function(v)
				if v.ClassName == "TouchTransmitter" and IsValid(v, true) then
					wait(1)
					ProgressTriggers[#ProgressTriggers + 1] = v.Parent
				end
			end
		]])(IsValid, ProgressTriggers)
		workspace.DescendantAdded:Connect(fix3ds)
	end

	--Tower--
	function TowerUtils:CheckForBossChests()
		return workspace:FindFirstChild("RaidChestGold") or workspace:FindFirstChild("RaidChestSilver")
	end

	local function IsAtRaidChestSpawn(chest)
		local chestSpawn1 = workspace.MissionObjects.MinibossChests.Spawn0 --the plate below the first of 2 chests
		local chestSpawn2 = workspace.MissionObjects.MinibossChests.Spawn1

		local chestBase = chest.ChestBase

		return (chestBase.Position - chestSpawn1.Position).magnitude < 10 or (chestBase.Position - chestSpawn2.Position).magnitude < 10
	end

	function TowerUtils:GetMiniBossChests()
		local miniBossChests = {}
		
		for i,v in pairs(workspace:GetChildren()) do
			if v.Name:find("RaidChest") and v.Top.Base.Orientation.X == 0 and IsAtRaidChestSpawn(v) then
				miniBossChests[#miniBossChests + 1] = v
			end
		end
		return miniBossChests
	end

	function TowerUtils:CollectBossChests()
		local miniBossChests = self:GetMiniBossChests()
		if #miniBossChests > 0 then
			--miniboss rewards--
			if #miniBossChests == 2 or #miniBossChests == 1 and game:GetService("MarketplaceService"):UserOwnsGamePassAsync(plr.UserId, 8136250) then
				SetAFStatus("Opening miniboss chest " .. (-#miniBossChests + 3)) --turn 2 to 1 and 1 to 2
				local chest = miniBossChests[1]
				plr.Character:SetPrimaryPartCFrame(chest.ChestBase.CFrame)
				wait(3)
			end
			--self:ExitMiniBoss()
			return true
		else
			--final boss rewards--
			for i,v in pairs(workspace:GetChildren()) do
				if v.Name:find("RaidChest") and v.Top.Base.Orientation.X == 0 then
					SetAFStatus("Opening boss rewards")
					plr.Character:SetPrimaryPartCFrame(v.ChestBase.CFrame)
					wait(3)
				end
			end
		end
	end

	function TowerUtils:CollectLootChests(type)
		local found = false
		if Settings.TowerLootChests then
			for i,v in pairs(workspace:GetChildren()) do
				if v.Name == type and v.Top.Base.Orientation.X == 0 and CheckChest(v) then
					found = true
					SetAFStatus("Opening loot chest")
					plr.Character:SetPrimaryPartCFrame(v.ChestBase.CFrame * CFrame.new(0,5,0))
					wait(1)
				end
			end
		end
		return found
	end

	function TowerUtils:ExitMiniBoss()
		SetAFStatus("Exiting floor")
		plr.Character:SetPrimaryPartCFrame(workspace.MissionObjects.MinibossExit.CFrame * CFrame.new(20,0,0))
		wait(1)
		plr.Character:SetPrimaryPartCFrame(workspace.MissionObjects.MinibossExit.CFrame)
		wait(1)
	end

	function TowerUtils:IsExitAvailable()
		return plr.PlayerGui.TowerVisual[KH_CONSTANT("TowerVisual")].KeyImage.TextLabel.Text:find("100%", 1, true) --or workspace.MissionObjects.FakeMissionStart.MissionTimer.SurfaceGui.Difficulty.Text == "Go!"
	end

	function TowerUtils:IsFloorFinished() --in new dungeons format with the chests icons
		local msgLabel = plr.PlayerGui.TowerVisual.TowerVisual.TowerChests.Crown.Message
		local purpleOverlay = plr.PlayerGui.TowerVisual.TowerVisual.TowerChests.Crown.Frame.Overlay
		if msgLabel.Text == "" and purpleOverlay.Size.Y.Scale == 1 then
			return true
		end
		local killed, all = msgLabel.Text:match("(%d+) / (%d+)")
		if killed and all and tonumber(killed) and tonumber(all) and killed == all then
			return true
		end
		return false
	end

	function TowerUtils:HolidayDungeonTick()
		local bossChest = workspace:FindFirstChild("RaidChestGold") or workspace:FindFirstChild("RaidChestSilver")
		if bossChest then
			local miniBossChests = {}
			for i,v in pairs(workspace:GetChildren()) do
				if v.Name:find("RaidChest") and v.Top.Base.Orientation.X == 0 then
					miniBossChests[#miniBossChests + 1] = v
				end
			end
			if #miniBossChests > 0 then
				Settings.CanAutoSell = true
				if #miniBossChests == 2 or #miniBossChests == 1 and game:GetService("MarketplaceService"):UserOwnsGamePassAsync(plr.UserId, 8136250) then
					local chest = miniBossChests[1]
					plr.Character:SetPrimaryPartCFrame(chest.ChestBase.CFrame)
					wait(3)
				end
			end
		end
	end

	function TowerUtils:Tower1Tick()
		workspace.FallenPartsDestroyHeight = -1000

		--boss-
		if Settings.GetBehindShields then
			SetAFStatus("Getting behind the shield")
			local shield = workspace.MissionObjects.IgnisShield
			if shield.Glow.BrickColor.Name ~= "Dirt brown" then
				plr.Character:SetPrimaryPartCFrame(shield.Ring.CFrame * CFrame.new(0,3,0))
			end

			return
		end

		--the rest--
		if not self:CheckForBossChests() or self:CollectBossChests() then
			if not self:CollectLootChests("VolcanicChestTower") then --first open all loot chests
				if self:IsFloorFinished() then
					SetAFStatus("Entering next floor")
					if workspace.MissionObjects:FindFirstChild("MinibossExit") then
						self:ExitMiniBoss()
					end
					if workspace:FindFirstChild("Map") then
						plr.Character:SetPrimaryPartCFrame(workspace.Map.Exit.EndTrigger.CFrame)
						wait(1)
					end
					plr.Character:SetPrimaryPartCFrame(workspace.MissionObjects.Teleporter.CFrame)
					wait(1)
				end
			end
		end
	end

	function TowerUtils:Tower2Tick()
		--boss-
		if Settings.FireCannon then
			SetAFStatus("Firing the cannon")
			local found = false
			for i,v in pairs(workspace:GetChildren()) do
				if v.Name == "KrakenPipe" and v:FindFirstChild("Active") and not v.Active.Value and #v.GuiPart:GetChildren() > 0 then
					found = true
					plr.Character:SetPrimaryPartCFrame(v.Base.CFrame * CFrame.new(0,3,0))
					break
				end
			end
			if not found then
				--plr.Character:SetPrimaryPartCFrame(workspace.MissionObjects.KrakenCannonBase.CFrame)
				plr.Character:SetPrimaryPartCFrame(workspace.KrakenCannon.Base.CFrame * CFrame.new(20,0,0))
				wait(1)
				plr.Character:SetPrimaryPartCFrame(workspace.KrakenCannon.Base.CFrame)
				wait(1)
			end
		end

		--the rest--
		if not self:CheckForBossChests() or self:CollectBossChests() then
			if not self:CollectLootChests("AtlanticChest") then --first open all loot chests
				if self:IsFloorFinished() then
					SetAFStatus("Entering next floor")
					if workspace.MissionObjects:FindFirstChild("MinibossExit") then
						self:ExitMiniBoss()
					end
				end
			end
		end
	end

	function TowerUtils:Tower3Tick(diff)
		--boss-
		if Settings.GetBehindShields then
			SetAFStatus("Getting behind the shield")
			for i,v in pairs(workspace.MissionObjects.Shields:GetChildren()) do
				if v.Glow.BrickColor.Name ~= "Dirt brown" then
					plr.Character:SetPrimaryPartCFrame(v.Ring.CFrame * CFrame.new(0,3,0))
					break
				end
			end
		end

		--chests--
		if not self:CheckForBossChests() or self:CollectBossChests() then
			if not self:CollectLootChests("AtlanticChest" --[[lmao they literally copy/pasted it from tower2]]) then
				if self:IsFloorFinished() then
					SetAFStatus("Entering next floor")
					if workspace.MissionObjects:FindFirstChild("MinibossExit") then
						self:ExitMiniBoss()
					end

					if workspace:FindFirstChild("Map") then
						plr.Character:SetPrimaryPartCFrame(workspace.Map.Exit.EndTrigger.CFrame)
						wait(1)
					end
					plr.Character:SetPrimaryPartCFrame(workspace.MissionObjects.Teleporter.CFrame)
					wait(1)
					--failsafe:
					if diff > 10 then
						plr.Character:SetPrimaryPartCFrame(workspace.MissionObjects.WaveStarter.CFrame)
						wait(1)
					end
				end
			end
		end
	end

	function TowerUtils:Tower4Tick(diff)
		--chests--
		if not self:CheckForBossChests() or self:CollectBossChests() then
			if not self:CollectLootChests("AtlanticChest") then
				if self:IsFloorFinished() then
					SetAFStatus("Entering next floor")
					if workspace.MissionObjects:FindFirstChild("MinibossExit") then
						self:ExitMiniBoss()
					end
					
					if workspace:FindFirstChild("Map") then
						plr.Character:SetPrimaryPartCFrame(workspace.Map.Exit.EndTrigger.CFrame)
						wait(1)
					end
					plr.Character:SetPrimaryPartCFrame(workspace.MissionObjects.Teleporter.CFrame)
					wait(1)
					--failsafe:
					if diff > 10 then
						plr.Character:SetPrimaryPartCFrame(workspace.MissionObjects.WaveStarter.CFrame)
						wait(1)
					end
				end
			end
		end
	end

	function TowerUtils:Tower5Tick(diff)
		--chests--
		if not self:CheckForBossChests() or self:CollectBossChests() then
			if not self:CollectLootChests("AtlanticChest") then
				if self:IsFloorFinished() then
					SetAFStatus("Entering next floor")
					if workspace.MissionObjects:FindFirstChild("MinibossExit") then
						self:ExitMiniBoss()
					end
					
					if workspace:FindFirstChild("Map") then
						plr.Character:SetPrimaryPartCFrame(workspace.Map.Exit.EndTrigger.CFrame)
						wait(1)
					end
					plr.Character:SetPrimaryPartCFrame(workspace.MissionObjects.Teleporter.CFrame)
					wait(1)
					--failsafe:
					if diff > 10 then
						plr.Character:SetPrimaryPartCFrame(workspace.MissionObjects.WaveStarter.CFrame)
						wait(1)
					end
				end
			end
		end
	end

	if Settings.IsTower then
		Settings.CanAutoSell = true

		local objective = plr.PlayerGui:WaitForChild("MissionObjective"):WaitForChild("MissionObjective"):WaitForChild("Label")
		objective:GetPropertyChangedSignal("Text"):Connect(function()
			if not Settings.Autofarm then
				return
			end

			local shields = objective.Text:match(KH_CONSTANT("Get behind the active shield! %((%d+)%)"))
			local tsunami = objective.Text:match(KH_CONSTANT("Tsunami inbound! Charge the cannon! %((%d+)%)"))
			if shields and tonumber(shields) then
				Settings.GetBehindShields = true
				Settings.ForceAutofarmExceptions = true
				Settings.LastAction = 0
				debugprint("label changed, shield!")
				for i,v in pairs(workspace.MissionObjects.Shields:GetChildren()) do
					if v.Glow.BrickColor.Name ~= "Dirt brown" then
						debugwarn("found a shield:", v:GetFullName(), v.Glow.BrickColor.Name)
						plr.Character:SetPrimaryPartCFrame(v.Ring.CFrame * CFrame.new(0,3,0))
						break
					end
				end
			elseif objective.Text:match("%d shields remaining!") then
				wait(2) --don't tp back at the moment of attack lol
				Settings.GetBehindShields = false
				Settings.ForceAutofarmExceptions = false
			elseif tsunami and tonumber(tsunami) then
				Settings.FireCannon = true
				Settings.ForceAutofarmExceptions = true
				Settings.LastAction = 0
				debugprint("label changed, cannon!")
			else
				--cancel cannon here??
				Settings.FireCannon = false
				Settings.ForceAutofarmExceptions = false
			end
		end)
		
		UiTbl.towerTab = NewUI:Tab("Tower Dungeon", {
			Width = 200
		})
		UiTbl.towerGroup = UiTbl.towerTab:Group("Tower")
		UiTbl.towerChestsCb = UiTbl.towerGroup:CheckBox("Collect Loot Chests", function(bool)
			Settings.TowerLootChests = bool
		end, "TowerLootChests")
		if Settings.TowerLootChests then
			UiTbl.towerChestsCb.Click()
		end
		UiTbl.lagLabel = UiTbl.towerGroup:Label("FPS Lag: 0ms")

		UiTbl.statusLabel = UiTbl.towerGroup:Label("Status: Idle")

		SetAFStatus = function(text)
			UiTbl.statusLabel.LabelObj.Text = text
		end

		--Fix Lag Delay display--
		coroutine.wrap(function()
			while true do
				local delay = math.floor((wait() - 1/30) * 1000)
				UiTbl.lagLabel.LabelObj.Text = string.format("FPS Lag: %sms", math.max(0, delay))
			end
		end)()
	end

	if Settings.IsTower or game.PlaceId == Dungeons.HolidayEvent then
		local towerFinish = plr:WaitForChild("PlayerGui"):WaitForChild("TowerFinish"):WaitForChild("TowerFinish"):WaitForChild("Description")
		local ev
		ev = towerFinish:GetPropertyChangedSignal("Text"):Connect(function()
			local count = towerFinish.Text:match(KH_CONSTANT("Collect your rewards! %((%d+)%)"))
			if count and tonumber(count) and tonumber(count) < 25 then
				local pass = 0
				for i,v in pairs(workspace:GetChildren()) do
					if (v.Name == "RaidChestGold" or v.Name == "RaidChestSilver") and v.Top.Base.Orientation.X == 0 then
						pass = pass + 1
						break
					end
				end

				if pass == 0 or game.PlaceId == Dungeons.HolidayEvent and pass == 1 and not game:GetService("MarketplaceService"):UserOwnsGamePassAsync(plr.UserId, 8136250) then
					if Settings.RestartDungeon then
						ev:Disconnect()
						wait(math.min(tonumber(count)-2, 4)) --wait 4 seconds unless the countdown has reached less than 6 seconds
						if Settings.AutoNextDungeon then
							UiTbl.nextDungeonBtn.Callback()
							wait(0.5)
						end
						RestartDungeon(false)
					end
				end
			end
		end)
	end

	if Settings.IsOpenWorld then
		UiTbl.openWorldTab = NewUI:Tab("Open World", {
			Width = 200
		})
		UiTbl.openWorldAutofarmGroup = UiTbl.openWorldTab:Group("World Events")

		local worldEvents = game.ReplicatedStorage:WaitForChild("Shared"):WaitForChild("WorldEvents")
		local activeEvents = worldEvents:WaitForChild("ActiveEvents")

		local intermissionTime

		local ownsDoubleChestPass = game:GetService("MarketplaceService"):UserOwnsGamePassAsync(plr.UserId, 8136250)

		local function isNaN(poo)
			return poo ~= poo
		end

		local function IsEventChest(chest, event)
			for i,v in pairs(workspace:GetChildren()) do
				if v.Name == event.Name then
					local chests = v:FindFirstChild("Chests")
					if chests then
						for i,v in pairs(chests:GetChildren()) do
							local dist = (v.Position - chest.ChestBase.Position).magnitude
							debugprint("dist", v:GetFullName(), dist)
							if dist <= 20 then
								return true
							end
						end
					end
				end
			end
			return false
		end

		local function GetFloor(event)
			local folder = workspace:FindFirstChild(event.Name)
			if folder and folder:FindFirstChild("Chests") and folder.Chests:FindFirstChildWhichIsA("BasePart") then
				return folder.Chests:FindFirstChildWhichIsA("BasePart").Position
			end
		end

		local lastEvent, eventBoss, eventTpPos, lastAutofarmPos
		UiTbl.openWorldAutofarmGroup:Slider({
			Min = 0,
			Max = 50,
			Default = 14,
			Fraction = 2,
			Parent = UiTbl.openWorldAutofarmGroup:CheckBox("Events Autofarm", function(bool)
				Settings.EventsAutofarm = bool

				lastEvent, eventBoss, eventTpPos, lastAutofarmPos = nil, nil, nil, nil
				local chestsRemaining = 2
				
				while Settings.EventsAutofarm do
					if plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
						if plr.Character:FindFirstChild("UpperTorso") and isNaN(plr.Character.UpperTorso.Position.magnitude) then --happens sometimes when loop tping, idk why
							SecureFireServer(game.ReplicatedStorage.Shared.Health.Reset)
						else
							local event = activeEvents:GetChildren()[1]
							if event and event.Started.Value then
								if event ~= lastEvent then
									lastEvent = event

									local be = Instance.new("BindableEvent")
									task.delay(2, function()
										SecureFireServer(worldEvents.TeleportToEvent, event.Name)
										wait(1)
										be:Fire()
									end)
									plr.Character.HumanoidRootPart:GetPropertyChangedSignal("CFrame"):Once(function()
										be:Fire()
									end)

									task.defer(SecureFireServer, worldEvents.TeleportToEvent, event.Name)
									be.Event:Wait()
									eventTpPos = plr.Character.HumanoidRootPart.CFrame
								end

								if not Settings.Killaura then
									Settings.Killaura = true
									task.spawn(UiTbl.killauraCb.Click)
								end
			
								if not eventBoss or not game:IsAncestorOf(eventBoss) then
									eventBoss = nil
									for i,v in pairs(workspace.Mobs:GetChildren()) do
										if v:FindFirstChild("FromSpawnPart") and v.FromSpawnPart.Value and v.FromSpawnPart.Value.Parent.Parent.Name == event.Name then
											eventBoss = v
											break
										end
									end
								elseif eventBoss.PrimaryPart then
									debugprint("tping to", eventBoss.PrimaryPart:GetFullName())

									local pos = CFrame.new(eventBoss.PrimaryPart.Position + Vector3.new(0,-Settings.EventFarmOffset,0))
									if Settings.EventFarmRespectFloor then
										local characterHeight = ({plr.Character:GetBoundingBox()})[2].Y/2
										local nameTagOffset = 2

										local floorPos = GetFloor(event)
										if floorPos and pos.Y + characterHeight + nameTagOffset > floorPos.Y then
											pos = CFrame.new(pos.X, floorPos.Y - characterHeight - nameTagOffset, pos.Z)
											debugwarn("adjusted position")
										elseif floorPos then
											debugwarn("GOOD POS", pos.Y + characterHeight + nameTagOffset, "<=", floorPos.Y)
										end
									end
									lastAutofarmPos = pos
									Teleport(pos)
								end
							else
								if Settings.Killaura then
									Settings.Killaura = false
									task.spawn(UiTbl.killauraCb.Click)
								end

								if lastEvent then
									--check chests--
									local found = false
									if Settings.EventFarmCollectChests then
										for i,v in pairs(workspace:GetChildren()) do
											if v.Name:find("RaidChest") and IsEventChest(v, lastEvent) and v.Top.Base.Orientation.X == 0 then
												if v.Name == "RaidChestGold" or (v.Name == "RaidChestSilver" and ownsDoubleChestPass) then
													found = true
													plr.Character:SetPrimaryPartCFrame(v.ChestBase.CFrame)
												end
											end
										end
									end
				
									if not found then
										Teleport(lastAutofarmPos)
									end
								end
							end
						end
					end
					game.RunService.Heartbeat:Wait()
				end
			end)
		}, function(val)
			Settings.EventFarmOffset = val
			return "Offset: " .. val
		end, "EventFarmOffset")

		UiTbl.openWorldAutofarmGroup:CheckBox("Collect Chests", function(bool)
			Settings.EventFarmCollectChests = bool
		end, "EventFarmCollectChests").Click()

		UiTbl.openWorldAutofarmGroup:CheckBox("Stay Underground", function(bool)
			Settings.EventFarmRespectFloor = bool
		end, "EventFarmRespectFloor").Click()

		local firstSeen = {}
		local notPrecise = {}
		activeEvents.ChildAdded:Connect(function(c)
			firstSeen[c] = os.time()
		end)
		for i,v in pairs(activeEvents:GetChildren()) do
			if v:FindFirstChild("IntermissionTimer") then
				firstSeen[v] = v.IntermissionTimer.Value --note to future self: this is off by like 13s, hence the code above (the game's code does the same except in a retarded way)
				notPrecise[v] = true
			end
		end

		local function UpdateLabel()
			local event = activeEvents:GetChildren()[1]
			if event and event.Name ~= "Template" then --template events are in marketplace for example
				if not intermissionTime then
					intermissionTime = require(worldEvents).INTERMISSION_TIME --declaring this here to avoid the dumb require() errors when executing early
				end

				UiTbl.openWorldEventLabel.LabelObj.Text = event.Name:gsub("(%l)(%L)", "%1 %2")
				if event:WaitForChild("Started").Value then
					UiTbl.openWorldEventStartedLabel.LabelObj.Text = "Started " .. (notPrecise[event] and "*around* " or "") .. (os.time() - (firstSeen[event] + intermissionTime)) .. "s ago"
				else
					UiTbl.openWorldEventStartedLabel.LabelObj.Text = "Starts in " .. (notPrecise[event] and "*around* " or "") .. (intermissionTime - (os.time() - firstSeen[event])) .. "s"
				end
			else
				UiTbl.openWorldEventLabel.LabelObj.Text = "None"
				UiTbl.openWorldEventStartedLabel.LabelObj.Text = "-"
			end
		end

		UiTbl.openWorldAutofarmGroup:Label("Current event:")
		UiTbl.openWorldEventLabel = UiTbl.openWorldAutofarmGroup:Label("None")
		UiTbl.openWorldEventStartedLabel = UiTbl.openWorldAutofarmGroup:Label("-")

		UiTbl.openWorldAutofarmGroup:Button("TP To Event", function()
			local event = activeEvents:GetChildren()[1]
			if event then
				SecureFireServer(worldEvents.TeleportToEvent, event.Name)
			end
		end)

		spawn(function()
			while true do
				UpdateLabel()
				wait(1)
			end
		end)

		if game.PlaceId == 5862275930 then --halloween event hub
			UiTbl.halloweenGroup = UiTbl.openWorldTab:Group("Halloween Event")
			UiTbl.halloweenGroup:Button("Complete Obby", function()
				SecureFireServer(game.ReplicatedStorage.Shared.Teleport.RequestTeleportFromPart, workspace.TeleportSystem.Part)
				plr.Character.HumanoidRootPart:GetPropertyChangedSignal("CFrame"):Wait()
				plr.Character:SetPrimaryPartCFrame(workspace.EventObbyReward.Part.CFrame)
			end)
		end
	end

	--reduce lag--
	coroutine.wrap(function()
		workspace:WaitForChild("Mobs").ChildAdded:Connect(function(mob)
			mob:WaitForChild("HealthProperties"):WaitForChild("Health").Changed:Connect(function(val)
				if val == 0 then
					game:GetService("Debris"):AddItem(mob, 0.2)
				end
			end)
		end)

		local f = require(game.ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Effects"))
		local old = f.DoEffect
		f.DoEffect = function(self, ...)
			local args = {...}
			if game.PlaceId == Dungeons.Tower3 and args[1] == "RadialIndicator" and Settings.Autofarm then
				args[5] = args[5] + 1 --make the indicators stay longer so that the autofarm has more time to dodge
				return old(self, unpack(args)) --at the same time don't apply NoEffects to them
			end
			return old(self, ...)
		end

		local old = f.RenderDamageNumber
		f.RenderDamageNumber = function(...)
			if Settings.NoDamageIndicators then
				return
			end
			return old(...)
		end
	end)()

	--blocking client-sided boss attack triggers for autofarm--
	do
		local blockedList = {
			DoLightningstorm = true,
			OnSpikeHit = true,
			OnMeteors = true,
			OnDarkOrb = true,
			OnThrow = true,
			IceBeam = true,
			OnWhipped = true,
			OnScratched = true,
			DoSpikes = true,
			OnFlamingSkull = true,
			MegaIceWall = true,
			OnPresentFall = true
		}
		local old = {}
		old[1] = hookmetamethod(game, "__namecall", loadstring([[
			local old, Settings, blockedList = ...

			return function(self, ...)
				local method = getnamecallmethod()
				if method == "FireServer" and blockedList[self.Name] and Settings.Autofarm then
					return
				end
				return old[1](self, ...)
			end
		]])(old, Settings, blockedList))
	end

	local VirtualUser = game:GetService("VirtualUser")
	plr.Idled:Connect(function()
		VirtualUser:CaptureController()
		VirtualUser:ClickButton2(Vector2.new())
	end)

	--Saving Settings--
	Settings.ExtraData = LoadSettings(GameName) or {
		AutoSellData = {},
	}
	if not Settings.ExtraData.AutoSellData then
		Settings.ExtraData = {
			AutoSellData = Settings.ExtraData,
		}
	end
	Settings.SettingsLoaded = true
	NewLib:RegisterGlobalClickEvent(function()
		SaveSettings(GameName, Settings.ExtraData)
	end)
